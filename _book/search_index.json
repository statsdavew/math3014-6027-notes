[["fractional-factorial.html", "Chapter 6 Fractional factorial designs 6.1 Estimability and aliasing", " Chapter 6 Fractional factorial designs The factorial designs we studied in Chapters 4 and 4 can involve a large number of treatments, for even a moderate number of factors (Table 6.1). size &lt;- data.frame(1:15, 2^(1:15)) knitr::kable(size, col.names = c(&quot;No. factors&quot;, &quot;No. of trts&quot;), caption = &quot;Number of treatments in a $2^f$ factorial designs for different numbers, $f$, of factors.&quot;) Table 6.1: Number of treatments in a \\(2^f\\) factorial designs for different numbers, \\(f\\), of factors. No. factors No. of trts 1 2 2 4 3 8 4 16 5 32 6 64 7 128 8 256 9 512 10 1024 11 2048 12 4096 13 8192 14 16384 15 32768 For larger numbers of factors, resource constraints may mean it is not possible to run an experiment using all \\(2^f\\) treatments. Also, many degrees of freedom in these experiments are used to estimate high-order interactions. For example, in a \\(2^5\\) experiment, 16 degrees of freedom are used to estimate three-factor and higher interactions, half the size of the experiment. The principles of effect hierarchy and sparsity (Section 4.2) suggest this is probably wasteful. We can select smaller experiments by using a subset, or fraction of the treatments of size \\(2^{f-q}\\): divide the treatments in subsets by confounding \\(q\\) factorial effects (and their products), as in blocking; only use one of the subsets in the experiment. Example 6.1 Spring experiment (Wu and Hamada, 2009, ch. 5) Consider an industrial experiment to investigate the effect of \\(f=5\\) factors on the unloaded height of a spring produced using a heat treatment. The five factors are described in Table 6.2. factor.name &lt;- c(&quot;Quench temperature (F)&quot;, &quot;Heat temperature (F)&quot;, &quot;Heating time (s)&quot;, &quot;Transfer time (s)&quot;, &quot;Hold-down time (s)&quot;) low.level &lt;- c(&quot;130-150&quot;, 1840, 23, 10, 2) high.level &lt;- c(&quot;150-170&quot;, 1880, 25, 12, 3) spring.factors &lt;- data.frame(factor = factor.name, low = low.level, high = high.level) row.names(spring.factors) &lt;- LETTERS[1:5] knitr::kable(spring.factors, col.names = c(&quot;Factor&quot;, &quot;Low level&quot;, &quot;High level&quot;), align = c(&quot;l&quot;, &quot;r&quot;, &quot;r&quot;), caption = &quot;Spring experiment: factors and levels&quot;) Table 6.2: Spring experiment: factors and levels Factor Low level High level A Quench temperature (F) 130-150 150-170 B Heat temperature (F) 1840 1880 C Heating time (s) 23 25 D Transfer time (s) 10 12 E Hold-down time (s) 2 3 Enough experimental units were available to perform \\(n=16\\) runs, which is one-half of the total number of treatments. We refer to this type of design as a one-half fractional replicate of the full factorial design, or a \\(2^{5-1}\\) fractional factorial design1. The design was constructed by confounding \\(q=1\\) factorial effects with blocks, the interaction \\(BCDE\\) was chosen, and running just one of the two resulting subsets, see Table 6.3 where FrF2 is used to generate the design. spring &lt;- FrF2::FrF2(nruns = 16, nfactors = 5, generators = &quot;BCD&quot;, randomize = F) spring$height &lt;- c(7.54, 7.20, 7.69, 7.63, 7.94, 7.40, 7.95, 7.62, 7.52, 7.52, 7.63, 7.65, 7.79, 7.29, 8.07, 7.73) knitr::kable(spring, caption = &quot;Spring experiment: 16 run design.&quot;, align = rep(&quot;r&quot;, 6)) Table 6.3: Spring experiment: 16 run design. A B C D E height -1 -1 -1 -1 -1 7.54 1 -1 -1 -1 -1 7.20 -1 1 -1 -1 1 7.69 1 1 -1 -1 1 7.63 -1 -1 1 -1 1 7.94 1 -1 1 -1 1 7.40 -1 1 1 -1 -1 7.95 1 1 1 -1 -1 7.62 -1 -1 -1 1 1 7.52 1 -1 -1 1 1 7.52 -1 1 -1 1 -1 7.63 1 1 -1 1 -1 7.65 -1 -1 1 1 -1 7.79 1 -1 1 1 -1 7.29 -1 1 1 1 1 8.07 1 1 1 1 1 7.73 Clearly, using a subset of the treatments, we will no longer be able to estimate all the factorial effects (we have insufficient degrees of freedom). We have confounded the interaction \\(BCDE\\), and hence clearly the contrast coefficients for this effect will be constant in our design. We say the interaction \\(BCDE\\) is aliased with the mean, and we write this as \\(I = BCDE\\). This expression is called the defining relation, as knowledge of which factorial effects are aliased with the mean completely define the fractional factorial. fac_to_numeric &lt;- function(x) as.numeric(as.character(x)) BCDE &lt;- fac_to_numeric(spring$B) * fac_to_numeric(spring$C) * fac_to_numeric(spring$D) * fac_to_numeric(spring$E) BCDE ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 This removes one factorial effect from consideration, but we are still short on degrees of freedom. What are the other consequences of using a fractional factorial design? As the contrast coefficients for the interaction \\(BCDE\\) are constant, the contrast coefficients for any pairs of factorial effects whose (hadamard) product form \\(BCDE\\) will be equal. For example, the contrast coefficient vectors for interactions \\(BC\\) and \\(DE\\) will be equal, as will the vectors for the main effect \\(B\\) and the interaction \\(CDE\\), and so on. BC &lt;- fac_to_numeric(spring$B) * fac_to_numeric(spring$C) DE &lt;- fac_to_numeric(spring$D) * fac_to_numeric(spring$E) BC DE all.equal(BC, DE) ## [1] 1 1 -1 -1 -1 -1 1 1 1 1 -1 -1 -1 -1 1 1 ## [1] 1 1 -1 -1 -1 -1 1 1 1 1 -1 -1 -1 -1 1 1 ## [1] TRUE B &lt;- fac_to_numeric(spring$B) CDE &lt;- fac_to_numeric(spring$C) * fac_to_numeric(spring$D) * fac_to_numeric(spring$E) B CDE all.equal(B, CDE) ## [1] -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 ## [1] -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 -1 -1 1 1 ## [1] TRUE We say these factorial effects are aliased. From the defining relation, we can derive the complete aliasing scheme for a fractional factorial design. For the example, \\[\\begin{align} I &amp; = BCDE \\\\ A &amp; = ABCDE \\\\ B &amp; = CDE \\\\ C &amp; = BDE \\\\ D &amp; = BCE \\\\ E &amp; = BCD \\\\ AB &amp; = ACDE \\\\ AC &amp; = ABDE \\\\ AD &amp; = ABCE \\\\ AE &amp; = ABCD \\\\ BC &amp; = DE \\\\ BD &amp; = CE \\\\ BE &amp; = CD \\\\ ABC &amp; = ADE \\\\ ABD &amp; = ACE \\\\ ABE &amp; = ACD \\\\ \\end{align}\\] The aliasing scheme contains \\(2^{f-q} = 2^{5-1} = 16\\) “strings”, each one containing \\(2^q = 2^1 = 2\\) “words”. The design is not capable to distinguishing between factorial effects in the same alias string. We can also generate this information using the aliases function from FrF2. spring.lm &lt;- lm(height ~ (.)^5, data = spring) FrF2::aliases(spring.lm) ## ## A = A:B:C:D:E ## B = C:D:E ## C = B:D:E ## D = B:C:E ## E = B:C:D ## A:B = A:C:D:E ## A:C = A:B:D:E ## A:D = A:B:C:E ## A:E = A:B:C:D ## B:C = D:E ## B:D = C:E ## B:E = C:D ## A:B:C = A:D:E ## A:B:D = A:C:E ## A:B:E = A:C:D Definition 6.1 A regular \\(2^{f-q}\\)fractional factorial design is constructed by aliasing \\(2^q-1\\) factorial effects with the mean; \\(q\\) of these effects can be chosen independently, the others are formed via the hadamard product of the contrast coefficients for the \\(q\\) effects, How do we chose the factorial effects to alias with the mean? As with blocking, we tend to choose higher-order effects, taking care when \\(q&gt;1\\) not to inadvertently alias together lower-order effects (see later examples). For Example 6.1, a slightly unusual defining relation was chosen. It would be more common to use \\(I = ABCDE\\), leading to the aliasing scheme: \\[\\begin{align} I &amp; = ABCDE \\\\ A &amp; = BCDE \\\\ B &amp; = ACDE \\\\ C &amp; = ABDE \\\\ D &amp; = ABCE \\\\ E &amp; = ABCD \\\\ AB &amp; = CDE \\\\ AC &amp; = BDE \\\\ AD &amp; = BCE \\\\ AE &amp; = BCD \\\\ BC &amp; = ADE \\\\ BD &amp; = ACE \\\\ BE &amp; = ACD \\\\ CD &amp; = ABE \\\\ CE &amp; = ABD \\\\ DE &amp; = ABC \\\\ \\end{align}\\] This defining relation results in main effects being aliased with four-factor interactions and, perhaps more importantly, no pairs of two-factor interactions aliased together. The original design from Example ?? might be used if factor \\(A\\) and its interactions were a priori thought likely to be important (two-factor interactions involving factor \\(A\\) are aliased with four-factor interactions). 6.1 Estimability and aliasing Any factorial effect in an alias string is only estimable if all other effects in that string are assumed zero2. Wd can study this further by introducing the alias matrix. Definition 6.2 Assume a linear data generating model \\[ \\bY = X_1\\boldsymbol{\\beta}_1 + X_2\\boldsymbol{\\beta}_2 + \\boldsymbol{\\varepsilon}\\,, \\] where \\(\\bY\\) is an \\(n\\)-vector of responses, \\(X_1\\) and \\(X_2\\) are \\(n\\times p_1\\) and \\(n\\times p_2\\) model matrices, respectively, with \\(\\boldsymbol{\\beta}_1\\) and \\(\\boldsymbol{\\beta}_2\\) corresponding \\(p_1\\)- and \\(p_2\\)-vectors of parameters and random errors \\(\\varepsilon ~ N(\\boldsymbol{0}, I_n\\sigma^2)\\). If the submodel \\[ \\bY = X_1\\boldsymbol{\\beta}_1 + \\boldsymbol{\\varepsilon}\\,, \\] is fitted to the response data, then \\(\\hat{\\boldsymbol{\\beta}}_1 = (X_1^{\\mathrm{T}}X_1)^{-1}X_1^{\\mathrm{T}}\\bY\\), and \\[\\begin{align*} E(\\hat{\\boldsymbol{\\beta}}_1) &amp; = \\boldsymbol{\\beta}_1 + (X_1^{\\mathrm{T}}X_1)^{-1}X_1^{\\mathrm{T}}X_2\\boldsymbol{\\beta}_2 \\\\ &amp; = \\boldsymbol{\\beta}_1 + A\\boldsymbol{\\beta}_2\\,, \\end{align*}\\] where \\(A = (X_1^{\\mathrm{T}}X_1)^{-1}X_1^{\\mathrm{T}}X_2\\) is the alias matrix. We also introduce an alternative definition of estimability. Definition 6.3 A linear combination of parameters \\(\\boldsymbol{c}^{\\mathrm{T}}\\boldsymbol{\\theta}\\) is estimable if and only if there exists a linear combination of the responses \\(\\boldsymbol{a}^{\\mathrm{T}}\\bY\\) such that \\[ E(\\boldsymbol{a}^{\\mathrm{T}}\\bY) = c^{\\mathrm{T}}\\boldsymbol{\\theta}\\,. \\] Now assume that using a two-level fractional factorial design, we will estimate one factorial effect (equivalently, the corresponding regression coefficient) from each alias string. Then the \\(A\\) matrix will have entries 0, -1 or +1, depending on the defining relation of the fraction. Each regression parameter will be biased by the parameters corresponding to other factorial effects in the alias string. Hence, by Definition @ref{def:alt-estimability}, each factorial effect is only estimable under the assumption that all other factorial effects in the alias string are zero. For Example 6.1 we can generate the alias matrix using the alias function. t(alias(spring.lm)$Complete) ## A1:C1:D1 A1:C1:E1 A1:D1:E1 B1:C1:D1 B1:C1:E1 B1:D1:E1 C1:D1:E1 ## (Intercept) 0 0 0 0 0 0 0 ## A1 0 0 0 0 0 0 0 ## B1 0 0 0 0 0 0 1 ## C1 0 0 0 0 0 1 0 ## D1 0 0 0 0 1 0 0 ## E1 0 0 0 1 0 0 0 ## A1:B1 0 0 0 0 0 0 0 ## A1:C1 0 0 0 0 0 0 0 ## A1:D1 0 0 0 0 0 0 0 ## A1:E1 0 0 0 0 0 0 0 ## B1:C1 0 0 0 0 0 0 0 ## B1:D1 0 0 0 0 0 0 0 ## B1:E1 0 0 0 0 0 0 0 ## A1:B1:C1 0 0 1 0 0 0 0 ## A1:B1:D1 0 1 0 0 0 0 0 ## A1:B1:E1 1 0 0 0 0 0 0 ## A1:B1:C1:D1 A1:B1:C1:E1 A1:B1:D1:E1 A1:C1:D1:E1 B1:C1:D1:E1 ## (Intercept) 0 0 0 0 1 ## A1 0 0 0 0 0 ## B1 0 0 0 0 0 ## C1 0 0 0 0 0 ## D1 0 0 0 0 0 ## E1 0 0 0 0 0 ## A1:B1 0 0 0 1 0 ## A1:C1 0 0 1 0 0 ## A1:D1 0 1 0 0 0 ## A1:E1 1 0 0 0 0 ## B1:C1 0 0 0 0 0 ## B1:D1 0 0 0 0 0 ## B1:E1 0 0 0 0 0 ## A1:B1:C1 0 0 0 0 0 ## A1:B1:D1 0 0 0 0 0 ## A1:B1:E1 0 0 0 0 0 ## A1:B1:C1:D1:E1 C1:D1 C1:E1 D1:E1 ## (Intercept) 0 0 0 0 ## A1 1 0 0 0 ## B1 0 0 0 0 ## C1 0 0 0 0 ## D1 0 0 0 0 ## E1 0 0 0 0 ## A1:B1 0 0 0 0 ## A1:C1 0 0 0 0 ## A1:D1 0 0 0 0 ## A1:E1 0 0 0 0 ## B1:C1 0 0 0 1 ## B1:D1 0 0 1 0 ## B1:E1 0 1 0 0 ## A1:B1:C1 0 0 0 0 ## A1:B1:D1 0 0 0 0 ## A1:B1:E1 0 0 0 0 References "]]
